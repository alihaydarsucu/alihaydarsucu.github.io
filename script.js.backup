document.addEventListener('DOMContentLoaded', function() {
    // Dark mode initialize
    const darkModeEnabled = localStorage.getItem('darkMode') === 'enabled';
    if (darkModeEnabled) {
        document.body.classList.add('dark-mode');
    }

    // Dark mode toggle functionality
    const darkModeToggle = document.querySelector('.theme-toggle input');
    const mobileDarkModeToggle = document.querySelector('.mobile-theme-toggle input');
    
    if (darkModeToggle) {
        darkModeToggle.checked = darkModeEnabled;
        darkModeToggle.addEventListener('change', function() {
            toggleDarkMode(this.checked);
        });
    }

    if (mobileDarkModeToggle) {
        mobileDarkModeToggle.checked = darkModeEnabled;
        mobileDarkModeToggle.addEventListener('change', function() {
            toggleDarkMode(this.checked);
        });
    }

    function toggleDarkMode(enable) {
        if (enable) {
            document.body.classList.add('dark-mode');
            localStorage.setItem('darkMode', 'enabled');
        } else {
            document.body.classList.remove('dark-mode');
            localStorage.setItem('darkMode', 'disabled');
        }
        
        // Sync both toggles
        if (darkModeToggle) darkModeToggle.checked = enable;
        if (mobileDarkModeToggle) mobileDarkModeToggle.checked = enable;
    }

    // Mobile menu functionality
    const hamburger = document.querySelector('.hamburger-menu');
    const mobileMenu = document.querySelector('.mobile-menu');
    const mobileMenuOverlay = document.querySelector('.mobile-menu-overlay');
    const mobileMenuClose = document.querySelector('.mobile-menu-close');
    
    if (hamburger) {
        hamburger.addEventListener('click', openMobileMenu);
    }
    
    if (mobileMenuClose) {
        mobileMenuClose.addEventListener('click', closeMobileMenu);
    }
    
    if (mobileMenuOverlay) {
        mobileMenuOverlay.addEventListener('click', closeMobileMenu);
    }
    
    // Close menu when clicking on links
    document.querySelectorAll('.mobile-nav-links a').forEach(item => {
        item.addEventListener('click', closeMobileMenu);
    });

    function openMobileMenu() {
        if (mobileMenu) mobileMenu.classList.add('active');
        if (mobileMenuOverlay) mobileMenuOverlay.classList.add('active');
        document.body.style.overflow = 'hidden';
    }

    function closeMobileMenu() {
        if (mobileMenu) mobileMenu.classList.remove('active');
        if (mobileMenuOverlay) mobileMenuOverlay.classList.remove('active');
        document.body.style.overflow = '';
    }

    // Back to top button
    const backToTopButton = document.querySelector('.back-to-top');
    if (backToTopButton) {
        window.addEventListener('scroll', function() {
            if (window.pageYOffset > 300) {
                backToTopButton.classList.add('active');
            } else {
                backToTopButton.classList.remove('active');
            }
        });

        backToTopButton.addEventListener('click', function(e) {
            e.preventDefault();
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        });
    }

    // GitHub Projects functionality
    if (document.getElementById('repos')) {
        loadGitHubProjects();
    }

    // GitHub Projects functionality
    async function loadGitHubProjects() {
        try {
            const response = await fetch('https://api.github.com/users/alihaydarsucu/repos?sort=updated&per_page=20');
            const repos = await response.json();
            
            if (Array.isArray(repos)) {
                displayRepos(repos);
                setupFilterButtons(repos);
            }
        } catch (error) {
            console.error('GitHub API error:', error);
            document.getElementById('repos').innerHTML = '<p style="text-align: center;">GitHub projeleri yüklenemedi.</p>';
        }
    }

    function displayRepos(repos, filter = 'all') {
        const reposContainer = document.getElementById('repos');
        if (!reposContainer) return;

        const filteredRepos = repos.filter(repo => {
            if (filter === 'all') return true;
            return categorizeRepo(repo) === filter;
        });

        reposContainer.innerHTML = '';

        filteredRepos.forEach((repo, index) => {
            const repoCard = document.createElement('div');
            repoCard.className = 'github-project-card';
            repoCard.style.animationDelay = `${index * 0.1}s`;

            const languageColor = getLanguageColor(repo.language);
            const lastUpdated = formatDate(repo.updated_at);

            repoCard.innerHTML = `
                <div class="github-project-header">
                    <h3 class="github-project-title">
                        <a href="${repo.html_url}" target="_blank">${repo.name}</a>
                    </h3>
                </div>
                <p class="github-project-description">${repo.description || 'Açıklama yok'}</p>
                <div class="github-project-meta">
                    ${repo.language ? `
                        <span class="github-project-language">
                            <span class="github-project-language-color" style="background-color: ${languageColor}"></span>
                            ${repo.language}
                        </span>
                    ` : ''}
                    <span class="github-project-stars">
                        <i class="fas fa-star"></i> ${repo.stargazers_count}
                    </span>
                    <span class="github-project-updated">
                        Güncellendi: ${lastUpdated}
                    </span>
                </div>
            `;

            setTimeout(() => {
                repoCard.classList.add('show');
            }, index * 100);

            reposContainer.appendChild(repoCard);
        });
    }

    function categorizeRepo(repo) {
        const webKeywords = ['html', 'css', 'javascript', 'web', 'react', 'vue', 'angular', 'portfolio'];
        const embeddedKeywords = ['arduino', 'embedded', 'firmware', 'iot', 'sensor', 'hardware'];
        
        const repoText = (repo.name + ' ' + (repo.description || '') + ' ' + (repo.language || '')).toLowerCase();
        
        if (webKeywords.some(keyword => repoText.includes(keyword))) {
            return 'web';
        } else if (embeddedKeywords.some(keyword => repoText.includes(keyword))) {
            return 'embedded';
        }
        
        return 'other';
    }

    function getLanguageColor(language) {
        const colors = {
            'JavaScript': '#f1e05a',
            'Python': '#3572A5',
            'HTML': '#e34c26',
            'CSS': '#563d7c',
            'Java': '#b07219',
            'C++': '#f34b7d',
            'C': '#555555',
            'TypeScript': '#2b7489',
            'Vue': '#2c3e50',
            'PHP': '#4F5D95'
        };
        return colors[language] || '#586069';
    }

    function formatDate(dateString) {
        const date = new Date(dateString);
        const now = new Date();
        const diffTime = Math.abs(now - date);
        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
        
        if (diffDays === 1) return '1 gün önce';
        if (diffDays < 30) return `${diffDays} gün önce`;
        if (diffDays < 365) return `${Math.floor(diffDays / 30)} ay önce`;
        return `${Math.floor(diffDays / 365)} yıl önce`;
    }

    function setupFilterButtons(repos) {
        const filterButtons = document.querySelectorAll('.filter-btn');
        
        filterButtons.forEach(button => {
            button.addEventListener('click', function() {
                // Remove active class from all buttons
                filterButtons.forEach(btn => btn.classList.remove('active'));
                // Add active class to clicked button
                this.classList.add('active');
                
                // Filter repos
                const filter = this.getAttribute('data-filter');
                displayRepos(repos, filter);
            });
        });
    }
});
